# 你的太阳落山了-OS大赛代码仓库

## 比赛选题：

- 基于优先级的的进程、线程、协程统一调度（好像名字打错了）
- 具体内容：算了不写了

## 开发日志：

- 2025.6.9：基本实现了用户态协程定义与简单调度，增加用户函数库，调度算法使用大根堆
- 

## 当前新增模块：

在`\user`中添加了`coroutine`模块，用于定义用户态协程，并实现了简单的调度算法。其中，`Coroutine`类用于定义协程，`Scheduler`类用于调度协程，`Scheduler`类中使用了大根堆算法进行调度。

### 特别说明：
- `CID`还没有写，我考虑其是否有必要写；
- `Scheduler`类还有点乱，我感觉需要在具体与线程整合后再完善；
- 测试代码简单的写了一个，而且很丑陋，后面需要很多的封装的函数啊啥的。

### 主要问题：
- 锁很sb，改的时候要小心
- 现在还完全没考虑线程的事情，目前只是封装了一下async和await，不过结合到线程中应该不算麻烦。

## 后续工作：
我的设计思路是：

> 取自微信聊天记录：用户态：实现三个类：`executor`，`coroutine`，`scheduler`，其中executor全局唯一，scheduler是每个线程有一个（？或者全局一个？然后把不同线程中的协程放进去，类似java的虚拟线程池的思想？）在coroutine中有个future：Mutex<Box<dyn Future>>，用来保持要执行的东西。这样在切换的时候我们就不需要考虑它的寄存器啊啥的（因为使用了Future的任务会被转换成状态机嘛）。当然之前的线程的操作啊啥的要进行一些调整。
内核态：TCB或者是PCB中存一个最大优先级和当前优先级两个参数，然后让时钟中断时想办法从scheduler中传回来着两个参数，然后把线程调度的那个RR改成基于优先级的RR（好像叫多级时间片轮转吧）
但是这样的问题是协程对内核是不可见的，而且协程还不能支持中断，因为是用的Future，所以实际上咱们自己是没有实现协程的，只不过是用了Rust的协程然后加入到rCore里面了

不过我现在的代码中`executor`是没有的，我目前不知道是否还需要，因为如果是一个线程一个调度器的话应该就不需要了。

后续最紧急的应该是尝试把协程和线程在用户态整合到一起，然后实现抢夺和`yield`（现在直接写一个future也太丑陋了）。

# 大概就这些