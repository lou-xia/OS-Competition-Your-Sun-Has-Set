# 设计方案

## 整体设计

在内核态，调度进程与线程；在用户态，调度线程与协程

### 内核态

内核态的调度沿用 rCore 中的设计，即 idle_task 作为陷入和返回的连接，其他线程在陷入内核切换时先切换到 idle_task，然后再由 processor 取下一个就绪线程执行。在 Trap 返回的过程中进行地址空间切换，从而在线程切换时间接的实现进程切换。

在此基础上，我们为线程加入了优先级，并将线程按照大根堆组织起来，以便于快速找到优先级最高的线程。当 processor 取线程时，队首的线程即为优先级最高的线程。

### 用户态

用户态的调度分为两部分：线程调度和协程调度。

线程的调度与内核相似，只不过在切换的过程中不用再考虑陷入等与内核相关的事情。为了实现内核态与用户态的线程切换相统一，我们参考了 vdso 技术的思路，设置了内核态和用户态的共享区。我们将就绪线程队列放在了共享区中，使得用户态可以直接访问就绪队列并进行线程调度，同时与内核态的线程队列和调度同步。

协程调度中，我们参考 tokio 的调度思路，为每个进程通过 lazy_static 的方式创建一个协程运行时 runtime，每个运行时中维护4个调度器 scheduler 《所以说为什么是4个啊？？？》，每个调度器维护一个任务队列，选择最高优先级的任务进行执行。同一进程的不同线程的协程会提交到同一个运行时中。

用户在提交协程时，需要设置其优先级，该优先级会被记录在协程的结构体中，并被放入相应的调度器的任务队列中。取当前线程提交的协程中优先级最高的协程的优先级作为该线程的调度优先级。

![架构图](./design_document_pic1.jpg)

## 协程设计

协程类 coroutine：基于`Future trait`实现，对每个协程分配`CID`，支持1-20级优先级。同时对协程实现比较的接口，方便在调度器中依据优先级和年龄进行协程的排序。

调度器 scheduler：基于`Future`和`Wait`机制实现，基于大根堆实现对其调度的每个协程进行管理与排序。调度器取出协程任务后，执行改协程的`poll`方法，如果执行结果为`Ready`，则更新当前的协程计数和最大优先级，并向上跟新线程优先级。如果执行结果为`Pending`，暂时不把它放回任务队列，等待其上下文的`Waker`调用`wake`后再将其放回。
> 这样做的好处是：只调度能立即执行的任务，减少无意义的 poll，提高高优先级任务的响应速度，同时在多处理器的情况下，能够降低调度器的锁竞争和队列操作开销。

**默认4个工作线程，每个线程运行独立调度器**《这里我还是不明白（）》

守护线程：用于将协程分配到调度器上，实现负载均衡。此外，还可以用守护线程实现定时器、信号处理等功能。
> 不过这不是本项目的重点，因此没有更多的实现。

协程同步：通过`Event`将实现协程同步。具体而言，`Event`中维护一个`Waker`对象，协程将自己运行代码中在该`Event`处等待，当其他协程调用改`Event`的`set`时，`Waker`对象将通知该协程并继续运行。

> 本质上讲，这种实现将`Event`也变为了一个协程，并通过调度器调度，在其他协程调用`set`时，`Event`的`Waker`对象将通知该协程并在调度器中直接运行，之后`Future`机制实现了再次`wake`前面的协程，从而实现协程同步。  
>>这样是否有些冗余？需要后续的进一步研究改进。

## 用户态线程切换与共享区设计

由于我们的协程都在用户态执行，同时协程运行时的正常运行中涉及到多个线程的切换，因此实现用户态线程切换是有必要的。在rCore中，线程被设计为内核级线程，用户态是无法参与线程调度的，因此我们需要想办法在用户态对内核级线程进行调度。

为了实现用户态线程调度，以及与内核态的线程切换相统一，我们参考了 vdso 技术的思路，设置了内核态和用户态的共享区，在内核态与用户态共用一个调度器。

共享区在内核态和用户态的地址空间中都硬编码地址为`2^64 - 256GB + 1`，大小为 17 个页面大小。其中第一个页面存放共享数据`VDSO_DATA`，剩下的页面作为共享堆空间，其中存放线程的`TaskSched`结构体，用来保存线程调度的上下文。

> 选择这个地址是因为在 RISC-V 64 架构中，启用 SV39 分页模式下，只有低 39 位是真正有意义的，高 25 位需要与第 38 位相同。在 rCore 的设计中，高 256G 的地址中页面是从高到低占用的，我们任务其几乎不可能占用全部的256G，较低地址位置一定是空闲的。因此选择这个地址不会对之前的设计造成影响。

共享区第一页的内容包括：

- task_manager：线程调度器，存储以下内容：
    - 线程队列：`[Arc<TaskSched, LockedHeapAllocator>; 128]`。这里的`LockedHeapAllocator`是一个堆分配器，将`TaskSched`对象分配在后16页的共享堆空间中，以便于线程调度时不会出现跨地址空间的问题。
    - 线程数量：usize。记录当前队列中线程的数量。不使用`AtomicUsize`是因为`AtomicUsize`在用户态调度时会先上锁，即下述的`block_sched`，防止被打断。
    - 空线程结构体，用来在排序时当作临时变量。
- current_task：其类型为`[Option<Arc<TaskSched, LockedHeapAllocator>>; PROCESSOR_NUM]`，用来保存当前各处理器正在处理的线程。
- block_sched: 其类型为`AtomicBool`，用来阻止用户态调度时被打断。当用户态在进行调度时，将其设置为`true`，此时内核的时钟中断将不再进行任务切换，防止用户态调度过程被打断后上下文错误保存。当用户态调度结束后，设置为`false`。

`TaskManager`实现了以下两个接口，方便内核态与用户态调度：
- `add()`：将线程加入线程队列，并按照大根堆组织顺序。
- `fetch()`：取出优先级最高的线程，并将剩下的任务按照大根堆组织顺序。

后 16 页内容为共享堆空间，用来存放线程的`TaskSched`结构体。这些结构体对象在线程创建时由内核初始化，并放入共享堆中。`TaskSched`记录线程调度时必须的上下文信息。

用户态线程调度的过程如下：

1. 用户态线程调用`yield_()`进入`user_schedule()`函数，开始用户态调度
2. `user_schedule()`函数取共享区数据，然后设置`block_sched`为`true`。然后从`current_task`中取出当前处理器运行的线程。如果取出失败则`panic!`
3. 判断就绪队列中最高优先级的线程是否与当前线程在一个地址空间，如果不是则先设置`block_sched`为`false`，再调用系统调用`sys_yield`由内核切换线程同时切换进程。
4. 调用`fetch()`，取出优先级最高的线程，修改当前线程和下一线程的状态，并通过汇编指令保存和加载线程上下文。
5. 修改`block_sched`为`false`，用户态线程调度结束。

此外，为了让此调度器在内核态也能进行调度，我们修改了 rCore 中的 TCB 等结构，以支持线程调度。