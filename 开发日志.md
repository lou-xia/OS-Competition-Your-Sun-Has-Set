# 开发日志

## 初赛阶段

### 2025-6-9

实现了用户态协程系统，包括：
- 基于Future的协程定义
- 多线程协程调度器
- 优先级队列调度算法
- 事件同步机制

### 2025-6-16
将原有的简单轮转调度改进为基于优先级的调度：
- 使用BTreeSet实现O(log n)的插入和查找
- 实现老化机制防止饥饿
- 支持动态优先级调整

### 2025-6-23
新增了多个系统调用支持协程-线程交互：
- `sys_thread_prio`: 动态调整线程优先级
- `sys_framebuffer`: 图形界面支持
- `sys_event_get`: 输入事件处理

### 2025-6-30
进行测试，并修复找到的bug：
- `scheduler`不能成功结束：`scheduler`线程的`wait`逻辑错误
- 添加测试程序：`coroutine_test.rs`、`coroutine_test_all.rs`、`coroutine_prior_test.rs`，分别进行简单协程测试、多线程协程测试、优先级调度测试

## 决赛阶段

### 2025-7-20
- 优化代码协程等待队列逻辑，让所有`scheduler`共享一个等待队列
- 增加守护线程，用于分配协程任务，防止协程的`yield`无效
- 优化任务分配逻辑，让poll的任务重新入队时通过共有的等待队列入队

### 2025-7-27
- 将`scheduler`的执行逻辑优化，`pending`的任务不再由`scheduler`维护进入队列
- 实现`waker`的逻辑，任务由`waker`唤醒后重新入队

### 2025-8-3
这周一（7-29）开会，商议后续安排：
第一步实现共享区，可以参考学长的设计  
第二步把rCore的线程调度器放在共享区，实现用户态线程调度
后续如果有时间可以把协程也通过这个调度器进行调度，并考虑中断的问题
- 实现了共享区，新增共享页面，地址为 2^64 - 256G + 1，大小为一个页面。
- 简单测试了共享区，可以正常读写数据

### 2025-8-10
这周一（8-4）再次开会，内容与上次基本相同，进一步加深了理解，解答了疑问
- 尝试实现调度器放共享区，初步提取线程调度的相关内容，建立结构体`TaskSched`和`TaskManager`
- 把调度相关代码在用户态实现，并简要修改
- 尝试在用户态实现线程调度，并测试，发现以下问题：
    - TaskSched结构在内核地址空间，用户态不可见，无法直接访问。解决方案：扩充共享区，增加16页空间，当作共享堆，内核态可见，用户态可访问。将TaskSched结构体放入共享堆，并在内核态初始化。并且之后不再能使用需要地址分配的库函数bTreeSet，需要自己实现。
    - 用户态无法访问S特权级寄存器，rCore的UPIntrSafeCell不可用。解决方案：自己实现类似结构：TicketLock，实现内部可变引用。
    - 当前cpu不能找到正在执行的任务，需要修改调度器，增加`current_task`变量。
    - 用户态调度过程中收到时钟中断会导致`TaskSched`混乱。解决方法：增加一个`AtomicBool`，用于标记是否在进行用户调度，进行时内核时钟中断直接返回。
    - 在内核态调度时，`TaskSched`的ra和sp是内核态的数据，如果出现从下一个任务是由内核切换到的，然后进行用户态调用，会把错误的上下文传入用户态。解决方案：增加额外的成员变量，记录用户态的ra和sp，在用户态调用时保存当前任务的上下文，切换到下一个任务时恢复上下文。
    - 用户态调度后没办法改变当前的`TrapContext`，因为在rCore的实现中，它被事先存放在sscrech中。待解决。
