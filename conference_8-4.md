总体而言，就是把调度器放在共享区里，这样在用户态就可以实现任务切换了（首先先把线程切换实现，再说协程的事情）：
首先，把调度器放在共享区，调度的线程，相当于把内核级线程变成用户级线程。（之前一直困扰我的是什么叫内核态线程，现在看来内核态线程可能指的就是内核级线程，也就是TCB在内核管理的，rcore是内核级线程）这样减少了每次进行任务切换都要进入内核态的开销。当然如果要跨进程调度，也就是需要换地址空间的时候（就是那个指针，token），依旧需要进入内核态。此后做个测试，看看在什么情况下性能会提升，能提升多少
其次考虑协程，在参考项目https://github.com/AoligeiY/embassy_preempt/tree/main中，是通过判断当前任务是否有栈来判断是否是线程，如果没栈那就是协程。如果当前是协程在调度，就可以复用堆栈（我的理解是所有协程，也就是impl future的函数，都在一个堆栈上）；如果是线程，那么需要在申请一个新的堆栈保存之前的内容（其实就是寄存器、和pc指针，函数调用关系我任务是也需要保存的，但是我看那个文档里没有提到），当切换回去的时候再把栈析构。这样做会有额外的栈申请与收回的开销，但是在需要高并发的条件下是可行的。
然后是中断处理，按照参考的项目，中断时如果当前任务是线程，只需要保存栈就可以了，协程则需要申请栈，保存上下文后再继续。（因为这之后处理中断，进入中断处理程序了以后，我的理解是相当于进入了另一个线程了，一定要把之前的任务流的现场保存好）。中断恢复的时候是反过来，恢复栈，包括回收协程的栈。