# 基于rCore的优先级协程、线程、进程统一调度系统

## 1. 目标描述

基于rCore操作系统，实现支持优先级的协程、线程、进程统一调度系统：
- 用户态协程系统：基于Rust Future的异步协程运行时
- 优先级调度机制：1-20级优先级调度框架
- 统一调度架构：协程、线程、进程统一管理

## 2. 比赛题目分析和相关资料调研

### 2.1 题目分析
实现要求：
1. 基于优先级进行调度
2. 进程/线程/协程的统一调度框架
3. 抢占式协程调度

### 2.2 技术挑战
- **多层次调度协调**：用户态协程与内核态线程的优先级传递
- **异步编程整合**：Future状态机与系统调度器的桥接
- **性能优化**：多线程调度器的锁竞争和负载均衡
- **调度公平性**：防饥饿的老化机制设计

## 3. 系统框架设计

### 3.1 整体架构
```
用户态:
┌─────────────────────────────────────┐
│ CoroutineRuntime (全局单例)          │
│ ├─ 4个工作线程                       │
│ ├─ 每线程一个Scheduler               │
│ └─ 负载均衡任务分配                  │
├─────────────────────────────────────┤
│ Scheduler (BinaryHeap优先级队列)     │
│ ├─ 协程优先级管理                    │
│ ├─ Future状态机调度                  │
│ └─ Waker机制异步唤醒                 │
├─────────────────────────────────────┤
│ Event/Coroutine 同步原语             │
└─────────────────────────────────────┘
               │ sys_thread_prio()
               ▼ 优先级传递
┌─────────────────────────────────────┐
│ 内核态 TaskManager                   │
│ ├─ BTreeSet<Task> 优先级队列         │
│ ├─ 动态优先级计算 (base + aging)      │
│ └─ 老化机制防饥饿                    │
└─────────────────────────────────────┘
```

### 3.2 核心组件
- **协程系统**：协程、协程调度器、协程运行时
- **内核调度器**：优先级系统调用、优先级调度
- **事件同步**：原子操作的Event原语，自定义Waker机制
- **同步优先级**：协程向线程传递优先级

## 4. 重要进展

- **协程运行时**：实现CoroutineRuntime管理4个工作线程，每线程独立Scheduler调度器
- **优先级调度**：内核BTreeSet替换轮转调度，支持动态优先级和老化防饥饿
- **跨层传递**：通过sys_thread_prio系统调用实现协程优先级向线程传递
- **异步集成**：Future状态机与自定义Waker机制，Event原语支持协程同步

## 5. 测试情况

### 5.1 功能测试
- 协程创建和调度
- 优先级调度验证  
- 事件同步机制
- 负载均衡测试

### 5.2 测试用例
```rust
pub fn test_for_coroutine() {
    let event = Arc::new(Event::new());
    
    let future1 = async move {
        event1.wait().await;
    };
    
    let future2 = async move {
        event2.set();
    };
    
    submit_coroutine(future1, 1);
    submit_coroutine(future2, 2);
    wait_all_coroutines();
}
```

## 6. 主要问题和解决方法

- **锁竞争**：细粒度锁，优化锁持有时间
- **优先级反转**：优先级继承机制，抢占式调度
- **内存管理**：Box<dyn Future>封装，ID分配器管理
- **调试困难**：详细日志，协程状态追踪

## 7. 提交仓库目录

### 7.1 核心文件
```
user/src/coroutine/
├── coroutine.rs    # 协程定义和优先级管理
├── scheduler.rs    # 协程调度器和Waker机制  
├── runtime.rs      # 多线程协程运行时
└── event.rs        # 事件同步机制

os/src/task/
├── manager.rs      # BTreeSet优先级调度器
└── id.rs          # 优先级常量定义
```

## 8. 比赛收获

通过这次比赛，我对协程有了更深层次的理解。以前只是简单地认为协程是轻量级线程，但在实际实现过程中才真正领悟到协程的本质是状态机的封装，Future trait将复杂的异步状态转换抽象为简洁的接口。当看到自己编写的async/await代码被编译器转换为状态机，并在自定义的调度器中优雅地切换执行时，那种掌控异步流程的成就感是无法言喻的。协程不仅仅是技术工具，更是一种全新的并发编程思维方式。