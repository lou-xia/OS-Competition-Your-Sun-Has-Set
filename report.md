# 基于rCore的优先级协程、线程、进程统一调度系统

## 1. 目标描述

本项目基于rCore操作系统，实现了一个支持优先级的协程、线程、进程统一调度系统。主要目标包括：

- **用户态协程系统**：实现基于Rust Future的异步协程运行时，支持多线程并行调度
- **优先级调度机制**：为协程、线程、进程提供统一的优先级调度框架（1-20级优先级）
- **统一调度架构**：将协程、线程、进程纳入统一的调度体系，实现高效的任务管理
- **事件同步机制**：提供协程间通信和同步原语，支持复杂的并发场景

## 2. 比赛题目分析和相关资料调研

### 2.1 题目分析
传统操作系统中，进程和线程是主要的执行单元，但随着异步编程和高并发需求的增长，协程作为轻量级的执行单元越来越重要。本项目旨在探索如何在操作系统层面统一管理这三种执行单元。

### 2.2 技术挑战
- **抽象层次差异**：协程运行在用户态，线程和进程运行在内核态
- **调度粒度问题**：协程调度频率远高于线程/进程调度
- **优先级传递**：如何将协程优先级传递到内核态调度器
- **性能开销**：统一调度可能带来的性能损失

### 2.3 相关技术调研
- **Rust异步生态**：基于Future trait的异步编程模型
- **rCore架构**：理解现有的进程/线程调度机制
- **协程实现**：研究Go goroutine、Kotlin coroutine等实现方案
- **优先级调度**：多级反馈队列、老化机制等经典算法

## 3. 系统框架设计

### 3.1 整体架构
```
用户态:
┌─────────────────────────────────────┐
│ 协程运行时 (Coroutine Runtime)        │
├─────────────────────────────────────┤
│ 多调度器 (Multiple Schedulers)       │
├─────────────────────────────────────┤
│ 事件同步 (Event Synchronization)     │
└─────────────────────────────────────┘
               │
               ▼ 系统调用
┌─────────────────────────────────────┐
│ 内核态线程/进程调度器                 │
├─────────────────────────────────────┤
│ 优先级任务管理器                     │
├─────────────────────────────────────┤
│ 老化机制防饥饿                       │
└─────────────────────────────────────┘
```

### 3.2 核心组件设计

#### 3.2.1 用户态协程系统
- **协程定义**：基于Future trait，支持1-20级优先级
- **运行时管理**：默认4个工作线程，每个线程运行独立调度器
- **负载均衡**：智能分配协程到任务数最少的调度器
- **生命周期管理**：支持协程创建、调度、完成、清理

#### 3.2.2 内核态调度器增强
- **统一优先级**：扩展TaskControlBlock支持动态优先级
- **BTreeSet调度队列**：使用平衡二叉树实现高效的优先级调度
- **老化机制**：防止低优先级任务饥饿
- **优先级继承**：协程优先级通过系统调用传递到线程

#### 3.2.3 事件同步机制
- **Event原语**：基于原子操作的事件通知机制
- **Waker系统**：自定义唤醒机制支持异步等待
- **协程间通信**：支持复杂的协程协作模式

## 4. 开发计划

### 第一阶段（已完成）：基础协程系统
- [x] 协程定义和基本调度
- [x] 多线程运行时架构
- [x] 事件同步机制
- [x] 基础测试用例

### 第二阶段（已完成）：内核调度器改进
- [x] 优先级调度算法
- [x] 老化机制实现
- [x] 系统调用扩展

### 第三阶段（已完成）：系统整合
- [x] 协程-线程优先级传递
- [x] 统一调度框架
- [x] 性能优化

### 第四阶段（进行中）：测试和优化
- [ ] 压力测试
- [ ] 性能分析
- [ ] 文档完善

## 5. 比赛过程中的重要进展

### 5.1 协程系统实现（2025.6.9）
实现了完整的用户态协程系统，包括：
- 基于Future的协程定义
- 多线程协程调度器
- 优先级队列调度算法
- 事件同步机制

### 5.2 内核调度器改进
将原有的简单轮转调度改进为基于优先级的调度：
- 使用BTreeSet实现O(log n)的插入和查找
- 实现老化机制防止饥饿
- 支持动态优先级调整

### 5.3 系统调用扩展
新增了多个系统调用支持协程-线程交互：
- `sys_thread_prio`: 动态调整线程优先级
- `sys_framebuffer`: 图形界面支持
- `sys_event_get`: 输入事件处理

## 6. 系统测试情况

### 6.1 功能测试
- **协程创建和调度**：测试协程的基本生命周期
- **优先级调度**：验证高优先级任务优先执行
- **事件同步**：测试协程间的等待和通知机制
- **负载均衡**：验证多调度器的任务分配

### 6.2 性能测试
- **调度延迟**：测试任务切换的开销
- **吞吐量**：测试系统的并发处理能力
- **内存使用**：分析协程的内存开销

### 6.3 测试用例
```rust
pub fn test_for_coroutine() {
    let event = Arc::new(Event::new());
    
    // 创建等待协程
    let event1 = event.clone();
    let future1 = async move {
        println!("[Task 1] waiting on event...");
        event1.wait().await;
        println!("[Task 1] event received!");
    };
    
    // 创建通知协程
    let event2 = event.clone();
    let future2 = async move {
        for i in 0..3 {
            println!("[Task 2] polling... round {}", i);
            dummy_yield().await;
        }
        println!("[Task 2] setting event");
        event2.set();
    };
    
    submit_coroutine(future1, 1);
    submit_coroutine(future2, 2);
    wait_all_coroutines();
    quit_coroutine_runtime();
}
```

## 7. 遇到的主要问题和解决方法

### 7.1 锁竞争问题
**问题**：多线程协程调度器存在严重的锁竞争
**解决方案**：
- 使用细粒度锁减少竞争范围
- 实现无锁数据结构（考虑中）
- 优化锁持有时间

### 7.2 优先级反转
**问题**：低优先级协程可能阻塞高优先级协程
**解决方案**：
- 实现优先级继承机制
- 协程优先级动态传递到线程
- 使用抢占式调度

### 7.3 内存管理
**问题**：协程栈和Future状态机的内存管理
**解决方案**：
- 使用Box<dyn Future>封装异步任务
- 实现协程ID分配器管理资源
- 优化内存分配策略

### 7.4 调试困难
**问题**：异步代码的调试和错误追踪困难
**解决方案**：
- 添加详细的日志输出
- 实现协程状态追踪
- 开发专用调试工具

## 8. 分工和协作

### 8.1 团队角色
本项目主要由个人完成，涉及多个技术领域：
- **系统架构设计**：整体框架和接口设计
- **协程系统开发**：用户态异步运行时实现
- **内核调度器改进**：内核态调度算法优化
- **系统整合测试**：端到端测试和性能调优

### 8.2 开发流程
- 采用迭代开发模式，每个阶段都有明确的目标
- 重视代码质量，保持良好的代码结构和注释
- 定期进行代码审查和重构

## 9. 提交仓库目录和文件描述

### 9.1 项目结构
```
OS-Competition-Your-Sun-Has-Set/
├── os/                          # 内核代码
│   ├── src/
│   │   ├── task/               # 任务管理模块
│   │   │   ├── manager.rs      # 优先级任务管理器
│   │   │   ├── id.rs          # 任务ID和优先级定义
│   │   │   └── ...
│   │   ├── syscall/           # 系统调用
│   │   │   ├── thread.rs      # 线程相关系统调用
│   │   │   └── ...
│   │   └── ...
├── user/                       # 用户程序
│   ├── src/
│   │   ├── coroutine/         # 协程系统
│   │   │   ├── mod.rs         # 模块入口和测试
│   │   │   ├── coroutine.rs   # 协程定义
│   │   │   ├── scheduler.rs   # 协程调度器
│   │   │   ├── runtime.rs     # 协程运行时
│   │   │   └── event.rs       # 事件同步机制
│   │   ├── io.rs              # I/O和图形接口
│   │   └── ...
├── easy-fs/                    # 文件系统
├── bootloader/                 # 引导程序
└── README.md                   # 项目说明
```

### 9.2 核心文件说明

#### 9.2.1 协程系统核心文件
- **`user/src/coroutine/coroutine.rs`**：协程定义，包含优先级管理和ID分配器
- **`user/src/coroutine/scheduler.rs`**：协程调度器，实现优先级调度和Waker机制
- **`user/src/coroutine/runtime.rs`**：协程运行时，管理多线程调度器
- **`user/src/coroutine/event.rs`**：事件同步，提供协程间通信原语

#### 9.2.2 内核调度系统
- **`os/src/task/manager.rs`**：任务管理器，实现基于BTreeSet的优先级调度
- **`os/src/task/id.rs`**：定义优先级常量和ID分配器
- **`os/src/syscall/thread.rs`**：线程相关系统调用，包括优先级设置

#### 9.2.3 测试和工具
- **`user/src/coroutine/mod.rs`**：包含协程系统测试用例
- **`user/src/io.rs`**：图形界面和输入处理
- **`ping.py`**：网络连接测试脚本

## 10. 比赛收获

### 10.1 技术收获
- **深入理解操作系统**：通过实际开发加深了对OS内核机制的理解
- **异步编程掌握**：熟练掌握了Rust的Future和async/await编程模型
- **系统设计能力**：学会了如何设计复杂的系统架构
- **调试技能提升**：掌握了内核级代码的调试方法

### 10.2 工程实践
- **代码组织**：学会了如何组织大型项目的代码结构
- **性能优化**：掌握了系统性能分析和优化方法
- **测试驱动开发**：重视测试用例的编写和维护
- **文档编写**：培养了良好的文档编写习惯

### 10.3 问题解决
- **系统思维**：学会了从系统整体角度分析问题
- **权衡取舍**：理解了设计中的各种权衡和取舍
- **持续改进**：培养了持续优化和改进的意识

### 10.4 未来展望
- **扩展功能**：计划添加更多的协程原语和调度策略
- **性能优化**：进一步优化系统性能和资源使用
- **实际应用**：探索在实际项目中的应用场景
- **开源贡献**：将成果贡献回开源社区

---

*本项目展示了现代操作系统中协程、线程、进程统一调度的可能性，为高并发应用提供了新的解决方案。*